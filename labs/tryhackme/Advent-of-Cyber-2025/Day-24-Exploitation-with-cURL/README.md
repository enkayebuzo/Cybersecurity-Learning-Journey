## üéÑ Advent of Cyber 2025 ‚Äì Day 24 - Exploitation with cURL ‚Äì Hoperation Eggsploit
## Overview
For Day 24, the goal was to interact with a web application without using a browser or GUI tools. I relied entirely on cURL and the command line to communicate with the server, identify endpoints, authenticate, and complete the mission.
All commands shown below are sanitized to avoid sharing solutions, credentials, or sensitive answers.

## üõ†Ô∏è How I Completed the Tasks
## Step 1: Environment Setup
I started by launching the AttackBox and the target machine. Since no browser was available, I prepared to inspect and interact with the application strictly through HTTP requests in the terminal.
## Step 2: Exploring the Application with GET Requests
To understand how the web application responded, I sent a basic GET request to the server and reviewed the raw HTML output directly in the terminal.
- curl http://MACHINE_IP/
This helped me confirm connectivity and understand how content is delivered without browser rendering.
# Step 3: Sending POST Requests
After identifying form-based interactions, I used cURL to simulate form submissions by sending POST requests with URL-encoded data.
- curl -X POST -d "username=<USER>&password=<PASSWORD>" http://MACHINE_IP/post.php
I also inspected response headers and status codes to better understand server behavior:
- curl -i -X POST -d "username=<USER>&password=<PASSWORD>" http://MACHINE_IP/post.php
# Step 4: Handling Cookies and Sessions
Once authentication was required, I captured session cookies from the server and reused them in subsequent requests to maintain login state.
Saving cookies:
- curl -c cookies.txt -d "username=<USER>&password=<PASSWORD>" http://MACHINE_IP/session.php
Reusing cookies:
- curl -b cookies.txt http://MACHINE_IP/session.php
This demonstrated how session persistence works behind the scenes in web applications.
# Step 5: Automating Requests with Bash
To avoid manually repeating requests, I created a simple bash loop to automate POST requests and analyze responses.
- for pass in $(cat passwords.txt); do
  response=$(curl -s -X POST -d "username=<USER>&password=$pass" http://MACHINE_IP/bruteforce.php)
  if echo "$response" | grep -q "<SUCCESS_INDICATOR>"; then
    echo "[+] Valid credentials detected"
    break
  fi
done
This helped me understand how brute-force tools work at a fundamental level.
# Step 6: Manipulating Headers (User-Agent)
I encountered a User-Agent restriction and tested how the server handled different headers. By spoofing the User-Agent, I was able to bypass the restriction.
- curl -A "<CUSTOM_USER_AGENT>" http://MACHINE_IP/agent.php
Comparing responses with and without the custom header confirmed the check.
# Step 7: Completion
After successfully interacting with all required endpoints and completing the mission objectives, I finished Day 24 with 100% completion.
# What I Learned
- How to manually craft and analyze HTTP requests and responses
- Practical use of cURL for web exploitation
- Session handling and cookie replay
- Bash scripting for basic automation
- How common tools like Burp Suite, Hydra, and WFuzz operate under the hood
# Screenshots 
